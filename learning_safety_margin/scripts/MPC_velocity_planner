#!/usr/bin/env python3

import pandas as pd
import numpy as np
import pickle
import rospy
import time
import sys
import os
from learning_safety_margin.robot_interface import RobotInterface

from sensor_msgs.msg import JointState
from std_msgs.msg import Header

from learning_safety_margin.cbf_mpc_vel_planner import *
from learning_safety_margin.vel_control_utils import *
from learning_safety_margin.msg import mpcCommand, mpcTraj

class MPC_vel_planner(object):

    def __init__(self):

        # create publisher and subscrber
        self.pub = rospy.Publisher("/cmd_mpc", mpcTraj, queue_size=10) # what should queue size be
        rospy.Subscriber("/ee_state", JointState, self.state_callback, queue_size=1)

        self.state = np.zeros(6)* np.nan

    def convert_cmd_msg(self, X,U,T):
        # convert data to custom cmd message for MPC control
        traj_msg = mpcTraj()

        for i in range(len(X[:, 0])):
            # Convert mpc X, U, T command to custom mpcCommand.msg format
            cmd = mpcCommand()
            cmd.time = T[i]
            cmd.position = X[i, 0:3]
            cmd.velocity = X[i, 3:6]

            # one less U than X due to forward sim
            if i < len(U[:, 0]):
                cmd.acceleration = U[i, 0:3]
            traj_msg.commands += [cmd]

        traj_msg.header.stamp = rospy.get_rostime()

        return traj_msg

    def state_callback(self, msg):

        # read current ee state of robot
        rospy.loginfo(rospy.get_caller_id() + "I heard %s \n", [msg.position, msg.velocity])

        # TODO : gonna need to convert/extract data somehow
        # self.raw_cmd = msg.data
        self.state[0:3] = np.asarray(msg.position)
        self.state[3:6] = np.asarray(msg.velocity)

    def planner_loop(self, planner, freq):

        rate = rospy.Rate(freq)

        while not rospy.is_shutdown():

            # wait until state is published
            if np.isnan(self.state).all():
                continue

            ## TODO : plan trajectory and publish cmd_mpc
            ## TODO : how to set target ??

            else :

                # Set target
                target = np.zeros(6)
                target[0:3] = [5., 0., 5.]

                # Set initial pose
                start = np.zeros(6)
                start[0:3] = self.state[0:3]

                # Calculate trajectory using MPC planner
                # print("MPC planning trajectory from %s \n to %s" % (start[0:3], target[0:3]))
                # start_time = time.time()
                X, U, T = planner.control(start, target)
                # print("Finished planning trajectory in %s seconds \n" % (time.time() - start_time))

                # Publish joint states for recording
                self.pub.publish(self.convert_cmd_msg(np.array(X), np.array(U), np.array(T)))

            rate.sleep()


# Controller to replay demonstrations
if __name__ == '__main__':

    rospy.init_node("plan", anonymous=True)

    # Check passed argument - User number
    if len(sys.argv) >= 2:
        user_number = sys.argv[1]
    else:
        user_number = '0'

    print("Running one_traj MPC Controller for User_"+user_number+"\n")

    # Get data
    data_dir = "/home/ros/ros_ws/src/learning_safety_margin/data/User_"+user_number+"/"

    data = pickle.load(open(data_dir + "vel_data_dict.p", "rb"))

    # Set up data for MPC planner
    params = data["theta"]
    bias_param = data["bias"]
    slack_param = data["unsafe_slack"]
    bias_param = 0.1

    # Initialize RBF Parameters
    # print(ws_lim, x_dim, n_dim_features, rbf_std)
    centers, stds = rbf_means_stds(X=None, X_lim=np.array([x_lim, y_lim, z_lim, vdot_lim, vdot_lim, vdot_lim]),
                                   n=x_dim, k=n_dim_features, fixed_stds=True, std=rbf_std)

    # SET PARAMETERS FOR MPC CONTROL
    freq = 500
    dt = 0.1  # 1./freq
    n_steps = 10

    # Init MPC controller
    print("Instantiating MPC Planner, should take around %s seconds... \n"%(n_steps/2))
    instantiate_start = time.time()
    mpc_planner = CBFMPC_Controller(centers, stds, params, bias_param, dt=dt, n_steps=n_steps)
    print("FINISH INSTANTIATING MPC PLANNER IN %s seconds \n" % (time.time() - instantiate_start))

    # Set save dir and create folder if needed
    save_dir = data_dir + "MPC/"
    if not os.path.isdir(save_dir):
        os.mkdir(save_dir)

    # Create planer object and start planning loop
    planner = MPC_vel_planner()

    planner.planner_loop(mpc_planner, freq)
