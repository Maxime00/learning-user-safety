#!/usr/bin/env python3

import numpy as np
import rospy
import state_representation as sr
from dynamical_systems import create_cartesian_ds, DYNAMICAL_SYSTEM_TYPE
from network_interfaces.control_type import ControlType
from network_interfaces.zmq.network import CommandMessage
from controllers import create_cartesian_controller, CONTROLLER_TYPE
from learning_safety_margin.robot_interface import RobotInterface
from sensor_msgs.msg import JointState
from std_msgs.msg import Header
from learning_safety_margin.msg import mpcCommand, mpcTraj



class MPC_vel_controller(object):
    def __init__(self, robot):
        self.robot = robot

        rospy.Subscriber("/cmd_mpc", mpcTraj, self.cmd_callback, queue_size=1)
        self.pub = rospy.Publisher('/ee_state', JointState, queue_size=1)

        self.read_message = False
        self.planner_ready = False
        self.elapsed_time = rospy.Duration()
        self.prev_loop_time = rospy.Time()

        self.decay_rate = 0.99
        self.alpha_cmd = 0.1995
        self.alpha_feedback = 0.2
        self.max_time_before_decay = 0.2  # seconds

        self.cmd_pos = np.zeros(3)

        self.raw_vel = np.zeros(6)
        self.filtered_vel = np.zeros(6)

        self.raw_acc = np.zeros(6)
        self.filtered_acc = np.zeros(6)

        self.timeZero = rospy.get_rostime()

    def convert_joint_state_msg(self, state):
        # Convert sr.joint_state msg to ros JointState msg -> ACTUALLY input cartesian pos and vel for MPC planner
        header = Header()

        # reset timeZero until planner is ready
        if not self.planner_ready:
            self.timeZero = rospy.get_rostime()
        header.stamp = rospy.get_rostime() - self.timeZero

        # header.frame_id = state.get_reference_frame() # is this important ??
        names = [state.ee_state.get_name()]
        pos = state.ee_state.get_position()
        vel = state.ee_state.get_linear_velocity()
        effort = state.ee_state.get_linear_acceleration()
        msg = JointState(header, names, pos, vel, effort)
        return msg

    def cmd_callback(self, msg):

        # grab cmd and set read_msg flag to true
        # rospy.loginfo(rospy.get_caller_id() + "I heard %s", msg.commands[-1])

        print("DESIRED POSITION : ", np.asarray(msg.commands[0].position), np.asarray(msg.commands[-1].position))
        print("DESIRED VELOCITY : ", np.asarray(msg.commands[0].velocity), np.asarray(msg.commands[-1].velocity))
        print("DESIRED ACCELERATION : ", np.asarray(msg.commands[0].acceleration), np.asarray(msg.commands[-1].acceleration))
        print("TIME SINCE LAST MESSAGE : ", self.elapsed_time.to_sec())

        # TODO : gonna need to convert/extract data somehow
        self.cmd_pos = np.asarray(msg.commands[-1].position)
        self.raw_vel[0:3] = np.asarray(msg.commands[-1].velocity)
        self.raw_acc[0:3] = np.asarray(msg.commands[0].acceleration)
        self.read_message = True

    def control_loop(self, freq):
        target_set = False

        command = CommandMessage()
        command.control_type = [ControlType.EFFORT.value]

        # SET UP CARTESIAN CTRL
        ctrl = create_cartesian_controller(CONTROLLER_TYPE.IMPEDANCE)

        ctrl.set_parameter_value("stiffness", [150, 150, 150, 10, 10, 10], sr.ParameterType.DOUBLE_ARRAY)  # 100 100 5 5 - good: 80 80 5 5
        ctrl.set_parameter_value("damping", [25, 25, 25, 4, 4, 4], sr.ParameterType.DOUBLE_ARRAY)  # 35 35 2. 2.5
        ctrl.set_parameter_value("inertia", [.25, .25, .25, .1, .1, .1], sr.ParameterType.DOUBLE_ARRAY)

        desired_state = sr.CartesianState('panda_ee', 'panda_base')
        feedback_state = sr.CartesianState('panda_ee', 'panda_base')

        dq_filtered = np.zeros(3)

        # Keep for orientation control
        ds = create_cartesian_ds(DYNAMICAL_SYSTEM_TYPE.POINT_ATTRACTOR)
        ds.set_parameter_value("gain", [0., 0., 0., 10., 10., 10.], sr.ParameterType.DOUBLE_ARRAY)

        rate = rospy.Rate(freq)
        while not rospy.is_shutdown():
            state = self.robot.get_state()

            # measure time since last loop
            period = rospy.Time.now() - self.prev_loop_time
            self.prev_loop_time = rospy.Time.now()

            if not state:
                continue

            # print("EEF position: ", state.ee_state.get_position())
            # print("EEF orientation: ", state.ee_state.get_orientation())

            if not target_set:
                target = sr.CartesianPose(state.ee_state.get_name(), np.array([.5, 0., .5]), np.array([0., 1., 0., 0.]),
                                          state.ee_state.get_reference_frame())

                ds.set_parameter_value("attractor", target, sr.ParameterType.STATE, sr.StateType.CARTESIAN_POSE)
                target_set = True

            # Received first command, set timeZero here
            if not self.planner_ready and self.read_message:
                self.timeZero = rospy.get_rostime()
                self.planner_ready = True

            # Main loop
            if self.planner_ready:

                ## Logic to set and filter command
                # Check if we have received new planned cmd and update elapsed time accordingly
                if self.read_message:
                    self.elapsed_time = rospy.Duration(0.0)
                    self.read_message = False
                elif not self.read_message:
                    self.elapsed_time += period

                # Check how long since last planned cmd and update command accordingly
                if self.elapsed_time.to_sec() < self.max_time_before_decay:
                    self.filtered_vel = self.alpha_cmd * self.filtered_vel + (1 - self.alpha_cmd) * self.raw_vel
                    self.filtered_acc = self.alpha_cmd * self.filtered_acc + (1 - self.alpha_cmd) * self.raw_acc
                else:
                    self.filtered_vel = self.alpha_cmd * self.filtered_vel + (1 - self.alpha_cmd) * 0
                    self.filtered_acc = self.alpha_cmd * self.filtered_acc + (1 - self.alpha_cmd) * 0

                ## SET and filter FEEDBACK state for controller
                feedback_state.set_position(state.ee_state.get_position())
                # filter velocities
                dq_filtered = (1 - self.alpha_feedback) * dq_filtered + self.alpha_feedback * state.ee_state.get_linear_velocity()
                feedback_state.set_linear_velocity(dq_filtered)

                ## SET DESIRED state
                desired_state.set_position(self.cmd_pos[0:3])
                desired_state.set_linear_velocity(self.filtered_vel[0:3])
                desired_state.set_linear_acceleration(self.filtered_acc[0:3])

                # TODO : add orientation control from DS here
                # twist = sr.CartesianTwist(ds.evaluate(state.ee_state))
                # twist.clamp(.25, .5)

                # Set command torques
                command_torques = sr.JointTorques(ctrl.compute_command(desired_state, feedback_state, state.jacobian))
                command.joint_state = state.joint_state
                command.joint_state.set_torques(command_torques.get_torques())

                self.robot.send_command(command)
                # print("Command:", command.joint_state.get_torques())

            self.pub.publish(self.convert_joint_state_msg(state))
            rate.sleep()


if __name__ == '__main__':

    rospy.init_node("ctrl", anonymous=True)

    robot_interface = RobotInterface("*:1701", "*:1702")
    controller = MPC_vel_controller(robot_interface)

    freq = 100

    controller.control_loop(freq)
