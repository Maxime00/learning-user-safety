#!/usr/bin/env python3

import numpy as np
import rospy
import state_representation as sr
from dynamical_systems import create_cartesian_ds, DYNAMICAL_SYSTEM_TYPE
from network_interfaces.control_type import ControlType
from network_interfaces.zmq.network import CommandMessage
from controllers import create_cartesian_controller, CONTROLLER_TYPE
from learning_safety_margin.robot_interface import RobotInterface
from sensor_msgs.msg import JointState
from std_msgs.msg import Header
from learning_safety_margin.msg import mpcCommand, mpcTraj

import matplotlib.pyplot as plt
from learning_safety_margin.vel_control_utils import *

class MPC_vel_controller(object):
    def __init__(self, robot):
        self.robot = robot

        rospy.Subscriber("/cmd_mpc", mpcTraj, self.cmd_callback, queue_size=1)
        self.pub = rospy.Publisher('/ee_state', JointState, queue_size=1)

        # MPC logic
        self.read_message = False
        self.planner_ready = False
        self.elapsed_time = rospy.Duration()
        self.prev_loop_time = rospy.Time()

        # control hyperparameters
        self.decay_rate = 0.99  # never used, what is this for ?
        self.theta_cmd = 0.9 # filter position cmd
        self.alpha_cmd = 0.95  # filter vel cmd
        self.beta_cmd = 0.995 #995  # filter acc cmd
        self.alpha_feedback = 0.85 # filter feedback vel
        self.beta_feedback = 0.97  # filter feedback acc -> only for recording anyway
        self.max_time_before_decay = 0.25  # seconds

        # Storing commands
        self.cmd_pos = np.zeros(3)
        self.filtered_pos = np.zeros(3)
        self.raw_vel = np.zeros(6)
        self.filtered_vel = np.zeros(6)
        self.raw_acc = np.zeros(6)
        self.filtered_acc = np.zeros(6)
        self.timeZero = rospy.get_rostime()
        self.nIterTime = rospy.Duration()

        self.full_time_idx = np.zeros(6)
        self.full_pos = np.zeros((6, 3))
        self.full_vel = np.zeros((6, 3))
        self.full_acc = np.zeros((6, 3))
        self.curr_idx = 0

        # data for plots
        self.recorded_state = np.zeros((15000, 1 + 3 * 6 + 7)) * np.nan
        self.idx = 0

    def plot_ref_vs_rec(self):

        traj_name = "test"

        # clean recorded data
        self.recorded_state = self.recorded_state[~np.isnan(self.recorded_state).any(axis=1)]
        # save file -> set save dir somewhere
        # np.save(save_dir + "_MPC_eeState", recorded_state, allow_pickle=False)

        # grab ref traj
        save_dir = "/home/ros/ros_ws/src/learning_safety_margin/data/User_0/MPC/ref_traj/"
        fn = save_dir + "raw_for_plot.npy"
        raw_ref = np.load(fn)

        # Formatting for ease
        rec_time = self.recorded_state[:, 0]
        ref_time = raw_ref[:,0]

        rec_pos = self.recorded_state[:, 1:4]
        ref_pos = raw_ref[:,1:4]
        rec_ref_pos = self.recorded_state[:, 10:13]
        error_pos = rec_pos - rec_ref_pos

        rec_vel = self.recorded_state[:, 4:7]
        ref_vel = raw_ref[:,4:7]
        rec_ref_vel = self.recorded_state[:, 13:16]
        error_vel = rec_vel - rec_ref_vel

        rec_acc = self.recorded_state[:, 7:10]
        ref_acc = raw_ref[:,7:10]
        rec_ref_acc = self.recorded_state[:, 16:19]
        error_acc = rec_acc - rec_ref_acc

        rec_tor = self.recorded_state[:, 19:26]

        print("PLOTTING REFERENCE VS RECORDED TRAJECTORY")

        # 3D position plot
        fig = plt.figure(figsize=(10, 10))
        ax = plt.axes(projection='3d')
        plt.plot(rec_pos[:, 0], rec_pos[:, 1], rec_pos[:, 2])
        plt.plot(rec_ref_pos[:, 0], rec_ref_pos[:, 1], rec_ref_pos[:, 2])
        plt.plot(ref_pos[:, 0], ref_pos[:, 1], ref_pos[:, 2])
        plt.xlim(ws_lim[0])
        plt.ylim(ws_lim[1])
        ax.set_zlim(ws_lim[2])
        fig.suptitle("EE pos vs ref of '{}'".format(traj_name))
        fig.legend(labels=['Recorded', 'Reference', 'Initial Ref'])

        # 3D velocity plot
        fig = plt.figure(figsize=(10, 10))
        ax = plt.axes(projection='3d')
        plt.plot(rec_vel[:, 0], rec_vel[:, 1], rec_vel[:, 2])
        plt.plot(rec_ref_vel[:, 0], rec_ref_vel[:, 1], rec_ref_vel[:, 2])
        plt.plot(ref_vel[:, 0], ref_vel[:, 1], ref_vel[:, 2])
        plt.xlim(np.array(vdot_lim) / 2)
        plt.ylim(np.array(vdot_lim) / 2)
        ax.set_zlim(np.array(vdot_lim) / 2)
        fig.suptitle("EE vel vs ref of '{}'".format(traj_name))
        fig.legend(labels=['Recorded', 'Reference', 'Initial Ref'])

        # Plot reference and state
        fig, axs = plt.subplots(3, 1)
        fig.suptitle("EE Position and reference of '{}'".format(traj_name))

        for i, ax in enumerate(axs.ravel()):
            ax.plot(rec_time[:], rec_pos[:, i])
            ax.plot(rec_time[:], rec_ref_pos[:, i])
            ax.plot(ref_time[:], ref_pos[:, i])
            ax.set(ylabel="Dim {}".format(i))
            ax.set(xlabel="Time [sec]")
        fig.legend(labels=['Recorded', 'Reference', 'Initial Ref'])

        # Plot position error
        # fig, axs = plt.subplots(3, 1)
        # fig.suptitle("EE position error of '{}'".format(traj_name))
        #
        # for i, ax in enumerate(axs.ravel()):
        #     ax.plot(rec_time, error_pos[:, i])
        #     ax.set(ylabel="Dim {}".format(i))
        #     ax.set(xlabel="Time [sec]")

        # Plot velocities and reference
        fig, axs = plt.subplots(3, 1)
        fig.suptitle("EE Velocity and reference of '{}'".format(traj_name))

        for i, ax in enumerate(axs.ravel()):
            ax.plot(rec_time, rec_vel[:, i])
            ax.plot(rec_time, rec_ref_vel[:, i])
            ax.plot(ref_time[:], ref_vel[:, i])
            ax.set(ylabel="Dim {}".format(i))
            ax.set(xlabel="Time [sec]")
        fig.legend(labels=['Recorded', 'Reference', 'Initial Ref'])

        # Plot velocity error
        # fig, axs = plt.subplots(3, 1)
        # fig.suptitle("EE Velocity error of '{}'".format(traj_name))
        #
        # for i, ax in enumerate(axs.ravel()):
        #     ax.plot(rec_time, error_vel[:, i])
        #     ax.set(ylabel="Dim {}".format(i))
        #     ax.set(xlabel="Time [sec]")

        # Plot acc and reference - no acceleration recorded
        fig, axs = plt.subplots(3, 1)
        fig.suptitle("EE acceleration and reference of '{}'".format(traj_name))

        for i, ax in enumerate(axs.ravel()):
            ax.plot(rec_time, rec_acc[:, i])
            ax.plot(rec_time, rec_ref_acc[:, i])
            ax.plot(ref_time[:], ref_acc[:, i])
            ax.set(ylabel="Dim {}".format(i))
            ax.set(xlabel="Time [sec]")
        fig.legend(labels=['Recorded', 'Reference', 'Initial Ref'])

        # Plot torque error
        # fig, axs = plt.subplots(3, 1)
        # fig.suptitle("EE acceleration error of '{}'".format(traj_name))
        #
        # for i, ax in enumerate(axs.ravel()):
        #     ax.plot(rec_time, error_acc[:, i])
        #     ax.set(ylabel="Dim {}".format(i))
        #     ax.set(xlabel="Time [sec]")

        # Plot torques
        fig, axs = plt.subplots(4, 2)
        fig.suptitle("Joint Torques of '{}'".format(traj_name))

        for i, ax in enumerate(axs.ravel()[:-1]):
            ax.plot(rec_time, rec_tor[:, i])
            ax.set(ylabel="joint {}".format(i))
            ax.set(xlabel="Time [sec]")

        plt.show()

    def convert_joint_state_msg(self, state):
        # Convert sr.joint_state msg to ros JointState msg -> ACTUALLY input cartesian pos and vel for MPC planner
        header = Header()

        # reset timeZero until planner is ready
        if not self.planner_ready:
            self.timeZero = rospy.get_rostime()
        header.stamp = rospy.get_rostime() - self.timeZero

        # header.frame_id = state.get_reference_frame() # is this important ??
        names = [state.ee_state.get_name()]
        pos = state.ee_state.get_position()
        vel = state.ee_state.get_linear_velocity()
        effort = state.joint_state.get_torques()  #  ee_state.get_linear_acceleration()
        msg = JointState(header, names, pos, vel, effort)
        return msg

    def cmd_callback(self, msg):

        # grab cmd and set read_msg flag to true
        # rospy.loginfo(rospy.get_caller_id() + "I heard %s", msg.commands[-1])

        # print("DESIRED POSITION : ", np.asarray(msg.commands[1].position), np.asarray(msg.commands[-1].position))
        # print("DESIRED VELOCITY : ", np.asarray(msg.commands[1].velocity), np.asarray(msg.commands[-1].velocity))
        # print("DESIRED ACCELERATION : ", np.asarray(msg.commands[0].acceleration), np.asarray(msg.commands[-2].acceleration))
        # print("TIME SINCE LAST MESSAGE : ", self.elapsed_time.to_sec())

        # TODO : gonna need to convert/extract data somehow

        ## TODO : should not overwrite those probably
        # for i in range(0,len(msg.commands)-1):
        #     self.full_time_idx[i] = msg.commands[i].time
        #     self.full_pos[i, :] = msg.commands[i].position
        #     self.full_vel[i, :] = msg.commands[i].velocity
        #     self.full_acc[i, :] = msg.commands[i].acceleration

        self.cmd_pos = np.asarray(msg.commands[1].position)
        self.raw_vel[0:3] = np.asarray(msg.commands[1].velocity)
        self.raw_acc[0:3] = np.asarray(msg.commands[0].acceleration)
        self.read_message = True

    def control_loop(self, freq):
        target_set = False

        command = CommandMessage()
        command.control_type = [ControlType.EFFORT.value]

        # SET UP CARTESIAN CTRL
        ctrl = create_cartesian_controller(CONTROLLER_TYPE.IMPEDANCE)

        ctrl.set_parameter_value("stiffness", [400, 400, 400, 10, 10, 10], sr.ParameterType.DOUBLE_ARRAY)  # 100 100 5 5 - good: 80 80 5 5
        ctrl.set_parameter_value("damping", [250, 250, 250, 4, 4, 4], sr.ParameterType.DOUBLE_ARRAY)  # 35 35 2. 2.5
        ctrl.set_parameter_value("inertia", [3.2, 3.2, 3.2, .1, .1, .1], sr.ParameterType.DOUBLE_ARRAY)
        # ctrl.set_parameter_value("stiffness", [150, 150, 150, 10, 10, 10], sr.ParameterType.DOUBLE_ARRAY)  # 100 100 5 5 - good: 80 80 5 5
        # ctrl.set_parameter_value("damping", [25, 25, 25, 4, 4, 4], sr.ParameterType.DOUBLE_ARRAY)  # 35 35 2. 2.5
        # ctrl.set_parameter_value("inertia", [.5, .5, .5, .1, .1, .1], sr.ParameterType.DOUBLE_ARRAY)
        # ctrl.set_parameter_value("stiffness", [10, 10, 10, 10, 10, 10], sr.ParameterType.DOUBLE_ARRAY)  # 100 100 5 5 - good: 80 80 5 5
        # ctrl.set_parameter_value("damping", [5, 5, 5, 4, 4, 4], sr.ParameterType.DOUBLE_ARRAY)  # 35 35 2. 2.5
        # ctrl.set_parameter_value("inertia", [.5, .5, .5, .1, .1, .1], sr.ParameterType.DOUBLE_ARRAY)

        desired_state = sr.CartesianState('panda_ee', 'panda_base')
        feedback_state = sr.CartesianState('panda_ee', 'panda_base')

        dq_filtered = np.zeros(3)
        ddq_filtered = np.zeros(3)

        # Keep for orientation control
        ds = create_cartesian_ds(DYNAMICAL_SYSTEM_TYPE.POINT_ATTRACTOR)
        ds.set_parameter_value("gain", [0., 0., 0., 10., 10., 10.], sr.ParameterType.DOUBLE_ARRAY)

        rate = rospy.Rate(freq)
        while not rospy.is_shutdown():
            state = self.robot.get_state()

            # measure time since last loop
            period = rospy.Time.now() - self.prev_loop_time
            self.prev_loop_time = rospy.Time.now()

            if not state:
                continue

            # print("EEF position: ", state.ee_state.get_position())
            # print("EEF orientation: ", state.ee_state.get_orientation())

            if not target_set:
                target = sr.CartesianPose(state.ee_state.get_name(), np.array([.5, 0., .5]), np.array([0., 1., 0., 0.]),
                                          state.ee_state.get_reference_frame())
                ds.set_parameter_value("attractor", target, sr.ParameterType.STATE, sr.StateType.CARTESIAN_POSE)
                target_set = True

            # Received first command, set timeZero here
            if not self.planner_ready and self.read_message:
                self.timeZero = rospy.get_rostime()
                self.filtered_pos = state.ee_state.get_position()
                self.planner_ready = True

            # Main loop
            if self.planner_ready:

                self.nIterTime = rospy.get_rostime() - self.timeZero

                # END OF LOOP
                if self.nIterTime.to_sec() > 10:
                    self.plot_ref_vs_rec()
                    break

                # Use time index to find cmd in full_cmd
                # self.curr_idx = np.abs(self.full_time_idx - self.nIterTime.to_sec()).argmin()
                # self.cmd_pos = self.full_pos[self.curr_idx, :]
                # self.raw_vel[0:3] = self.full_vel[self.curr_idx, :]
                # self.raw_acc[0:3] = self.full_acc[self.curr_idx, :]

                ## FILTER Position
                self.filtered_pos = self.theta_cmd * self.filtered_pos + (1 - self.theta_cmd) * self.cmd_pos

                ## Logic to set and filter command
                # Check if we have received new planned cmd and update elapsed time accordingly
                if self.read_message:
                    self.elapsed_time = rospy.Duration(0.0)
                    self.read_message = False
                elif not self.read_message:
                    self.elapsed_time += period

                # Check how long since last planned cmd and filter command accordingly
                if self.elapsed_time.to_sec() < self.max_time_before_decay:
                    self.filtered_vel = self.alpha_cmd * self.filtered_vel + (1 - self.alpha_cmd) * self.raw_vel
                    self.filtered_acc = self.beta_cmd * self.filtered_acc + (1 - self.beta_cmd) * self.raw_acc
                else:
                    self.filtered_vel = self.alpha_cmd * self.filtered_vel + (1 - self.alpha_cmd) * 0
                    self.filtered_acc = self.beta_cmd * self.filtered_acc + (1 - self.beta_cmd) * 0


                ## SET and filter FEEDBACK state for controller
                feedback_state.set_position(state.ee_state.get_position())
                # filter velocities
                dq_filtered = self.alpha_feedback * dq_filtered + (1-self.alpha_feedback) * state.ee_state.get_linear_velocity()
                feedback_state.set_linear_velocity(dq_filtered)

                ## SET DESIRED state
                desired_state.set_position(self.filtered_pos)
                desired_state.set_linear_velocity(self.filtered_vel[0:3])
                desired_state.set_linear_acceleration(self.filtered_acc[0:3])

                # TODO : add orientation control from DS here
                # twist = sr.CartesianTwist(ds.evaluate(state.ee_state))
                # twist.clamp(.25, .5)

                # compute linear acceleration for data_recording
                if not np.isnan(self.recorded_state[self.idx-1, 0]):
                    acc = (feedback_state.get_linear_velocity() - self.recorded_state[self.idx-1, 4:7])/period.to_sec()
                    ddq_filtered = self.beta_feedback * ddq_filtered + (1-self.beta_feedback) * acc

                # SAVE current state
                self.recorded_state[self.idx, 0] = self.nIterTime.to_sec()
                self.recorded_state[self.idx, 1:4] = feedback_state.get_position()
                self.recorded_state[self.idx, 4:7] = feedback_state.get_linear_velocity()
                self.recorded_state[self.idx, 7:10] = ddq_filtered
                self.recorded_state[self.idx, 10:13] = self.filtered_pos
                self.recorded_state[self.idx, 13:16] = self.filtered_vel[0:3]
                self.recorded_state[self.idx, 16:19] = self.filtered_acc[0:3]
                self.idx += 1

                # Set command torques
                command_torques = sr.JointTorques(ctrl.compute_command(desired_state, feedback_state, state.jacobian))
                command.joint_state = state.joint_state
                command.joint_state.set_torques(command_torques.get_torques())

                self.recorded_state[self.idx, 19:26] = command.joint_state.get_torques()

                self.robot.send_command(command)
                # print("Command:", command.joint_state.get_torques())

                # set state torques to read them in topic
                state.joint_state.set_torques(command_torques.get_torques())

            self.pub.publish(self.convert_joint_state_msg(state))
            rate.sleep()


if __name__ == '__main__':

    rospy.init_node("ctrl", anonymous=True)

    robot_interface = RobotInterface("*:1701", "*:1702")
    controller = MPC_vel_controller(robot_interface)

    freq = 200

    controller.control_loop(freq)
